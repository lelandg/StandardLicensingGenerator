using System;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Text.Json;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace StandardLicensingGenerator.UiSettings;

public class WindowSettingsManager
{
    private readonly Window _window;
    private readonly string _filePath;
    private readonly Dictionary<string, FrameworkElement> _controls = new();

    public WindowSettingsManager(Window window, string? fileName = null)
    {
        _window = window ?? throw new ArgumentNullException(nameof(window));

        string appName = Assembly.GetEntryAssembly()?.GetName().Name ?? "Application";
        string folder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), appName);
        Directory.CreateDirectory(folder);

        string name = fileName ?? $"{_window.GetType().Name}.json";
        _filePath = Path.Combine(folder, name);

        // If the window is already loaded, scan controls immediately
        if (_window.IsLoaded)
        {
            ScanControls();
            Load();
        }
        else
        {
            // Otherwise wait for the Loaded event
            _window.Loaded += (sender, args) =>
            {
                ScanControls();
                Load();
            };
        }
    }

    private void ScanControls()
    {
        _controls.Clear();

        // First, try to find named elements directly using FindName
        if (_window.Content is FrameworkElement rootElement)
        {
            var allNamedElements = FindAllNamedElements(rootElement);
            foreach (var element in allNamedElements)
            {
                if (!string.IsNullOrEmpty(element.Name))
                    _controls.TryAdd(element.Name, element);
            }
        }

        // Then use the tree helper methods as a backup
        foreach (var fe in FindNamedControls(_window))
        {
            if (!string.IsNullOrEmpty(fe.Name))
                _controls.TryAdd(fe.Name, fe);
        }
    }

    private List<FrameworkElement> FindAllNamedElements(FrameworkElement element)
    {
        var result = new List<FrameworkElement>();

        // Use reflection to find all x:Name fields in the window's class
        var type = _window.GetType();
        var fields = type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic);

        foreach (var field in fields)
        {
            // Fields generated by x:Name will be of a control type
            if (typeof(FrameworkElement).IsAssignableFrom(field.FieldType))
            {
                if (field.GetValue(_window) is FrameworkElement control && !string.IsNullOrEmpty(control.Name))
                {
                    result.Add(control);
                }
            }
        }

        return result;
    }

    private static IEnumerable<FrameworkElement> FindNamedControls(DependencyObject parent)
    {
        // Search the logical tree first (important for XAML-defined elements)
        if (parent is FrameworkElement parentElement)
        {
            foreach (object child in LogicalTreeHelper.GetChildren(parentElement))
            {
                if (child is FrameworkElement childElement)
                {
                    if (!string.IsNullOrEmpty(childElement.Name))
                        yield return childElement;

                    foreach (var grand in FindNamedControls(childElement))
                        yield return grand;
                }
            }
        }

        // Also search the visual tree
        for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
        {
            var child = VisualTreeHelper.GetChild(parent, i);
            if (child is FrameworkElement fe && !string.IsNullOrEmpty(fe.Name))
            {
                yield return fe;
            }

            foreach (var grand in FindNamedControls(child))
                yield return grand;
        }
    }

    private void Load()
    {
        if (!File.Exists(_filePath))
            return;
        try
        {
            string json = File.ReadAllText(_filePath);
            var settings = JsonSerializer.Deserialize<WindowSettings>(json);
            if (settings != null)
            {
                settings.ApplyTo(_window);
                if (settings.ControlValues != null)
                    ApplyControlValues(settings.ControlValues);
            }
        }
        catch
        {
            // ignore invalid files
        }
    }

    public void Save()
    {
        // Ensure we have all named controls before saving
        if (_controls.Count == 0)
        {
            ScanControls();
        }

        var settings = new WindowSettings
        {
            Top = _window.Top,
            Left = _window.Left,
            Width = _window.Width,
            Height = _window.Height,
            WindowState = _window.WindowState,
            ControlValues = GetControlValues()
        };

        var json = JsonSerializer.Serialize(settings, new JsonSerializerOptions { WriteIndented = true });
        File.WriteAllText(_filePath, json);
    }

    private Dictionary<string, string> GetControlValues()
    {
        var values = new Dictionary<string, string>();
        foreach (var kvp in _controls)
        {
            switch (kvp.Value)
            {
                case TextBox tb:
                    values[kvp.Key] = tb.Text;
                    break;
                case PasswordBox pb:
                    // Intentionally skip saving password values for security reasons
                    // If you need to save password values, encrypt them before storing
                    break;
                case ComboBox cb:
                    values[kvp.Key] = cb.SelectedIndex.ToString();
                    break;
                case CheckBox chk:
                    values[kvp.Key] = chk.IsChecked?.ToString() ?? string.Empty;
                    break;
                case DatePicker dp:
                    values[kvp.Key] = dp.SelectedDate?.ToString("o") ?? string.Empty;
                    break;
            }
        }
        return values;
    }

    private void ApplyControlValues(Dictionary<string, string> values)
    {
        foreach (var kvp in values)
        {
            if (!_controls.TryGetValue(kvp.Key, out var control))
            {
                // Try to find the control directly if it wasn't found in the initial scan
                var element = _window.FindName(kvp.Key) as FrameworkElement;
                if (element == null)
                    continue;

                control = element;
                _controls[kvp.Key] = element; // Add to our collection for future use
            }

            switch (control)
            {
                case TextBox tb:
                    tb.Text = kvp.Value;
                    break;
                case PasswordBox pb:
                    // We skip loading password values for security reasons
                    // If you had saved encrypted passwords, you would decrypt them here
                    break;
                case ComboBox cb:
                    if (int.TryParse(kvp.Value, out int index) && index >= 0 && index < cb.Items.Count)
                        cb.SelectedIndex = index;
                    else
                        cb.Text = kvp.Value;
                    break;
                case CheckBox chk:
                    if (bool.TryParse(kvp.Value, out bool b))
                        chk.IsChecked = b;
                    break;
                case DatePicker dp:
                    if (DateTime.TryParse(kvp.Value, out DateTime dt))
                        dp.SelectedDate = dt;
                    break;
            }
        }
    }
}

